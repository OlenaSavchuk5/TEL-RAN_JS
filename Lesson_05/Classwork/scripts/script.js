// ===================// Задачи ДЗ //==========================

// Напишите функцию camelize(str), которая преобразует строки вида «my-short-string» в «myShortString».

// То есть дефисы удаляются, а все слова после них получают заглавную букву.

// Примеры:

// camelize("background-color") == 'backgroundColor';
// camelize("list-style-image") == 'listStyleImage';
// camelize("-webkit-transition") == 'WebkitTransition';
// P.S. Подсказка: используйте split, чтобы разбить строку на массив символов, потом переделайте
// всё как нужно и методом join соедините обратно.

function camelize(str) {
    return str
      .split("-")
      .map((word, index) => {
        if (index == 0) {
          return word;
        } else {
          word[0].toUpperCase() + word.slice(1);
        }
      })
      .join("");
  }
  
  console.log(camelize("my-short-string"));
  
  function camelize(str) {
    return str
      .split("-")
      .map((word, index) =>
        index == 0 ? word : word[0].toUpperCase() + word.slice(1)
      )
      .join("");
  }
  console.log(camelize("my-short-string"));
  

// Написать функцию, принимающую массив чисел
// и возвращающую сумму всех его положительных элементов и отрицательных
// чисел отдельно в виде нового массива

// например функция принимает как аргумент следующий массив
// arr = [1, -2, 3, 4, -9, 6]
  
// и должна вернуть [14, -11]
  
  
  let getPosNegSum = (array) => {
    let positive = 0;
    let negative = 0;
    for (let i = 0; i < array.length; i++) {
      if (array[i] > 0) {
        positive += array[i];
      } else if (array[i] < 0) {
        negative += array[i];
      }
    }
    return [positive, negative];
  };
  
  console.log(getPosNegSum([1, -2, 3, 4, -9, 6]));


//================// Перебор: forEach //==========================
// Метод arr.forEach позволяет запускать функцию для каждого элемента массива

// Его синтаксис:
// arr.forEach(
// 		function(item, index, array) {
// 	  // ... делать что-то с item
// 		}
// );

// Например, этот код выведет на экран каждый элемент массива:
// Вызов console.log для каждого элемента
// ["Bilbo", "Gandalf", "Nazgul"].forEach(
// 	(item, index, array) => {
// 	  console.log(`${item} имеет позицию ${index} в ${array}`);
// 	  console.log(array);
// 	}
// );

// includes - Поиск в массиве
// arr.includes(item, from) – ищет item, начиная с индекса from,
// и возвращает true, если поиск успешен.

// let arr = [1, 0, false];
// console.log( arr.includes(1) ); // true

// const arr = [NaN];
// console.log( arr.includes(NaN) );// true (верно)

// углубленный поиск в массиве find
// Представьте, что у нас есть массив массивов.
// Как нам найти вложенный массив с определённым условием?

// Здесь пригодится метод arr.find.
// Его синтаксис таков:
// let result = arr.find(
// 		function(item, index, array) {
// 	  // если true - возвращается текущий элемент и перебор прерывается
// 	  // если все итерации оказались ложными, возвращается undefined
// 	}
// );

// Функция вызывается по очереди для каждого элемента массива:
// item – очередной элемент.
// index – его индекс.
// array – сам массив.
// Если функция возвращает true, поиск прерывается и возвращается item.
// Если ничего не найдено, возвращается undefined.

// Например, у нас есть массив c массивами пользователей,
// каждый из которых имеет первым элементом фамилию, вторым имя.
// Попробуем найти того, кто с фамилией Агранова

// let users = [
//   ['Иванов', "Вася"],
//   ['Петров', "Петя"],
//   ['Агранова', "Соня"],
// ];

// let user = users.find(item => item[0] == 'Агранова');

// console.log(user); //

// отфильтровать массив - filter
// Синтаксис этого метода схож с find, но
// filter возвращает массив из всех подходящих элементов

// let results = arr.filter(function(item, index, array) {
//   // если true - элемент добавляется к результату, и перебор продолжается
//   // возвращается пустой массив в случае, если ничего не найдено
// });

// let users = [
//   ['Иванов', "Вася"],
//   ['Агранова', "Петя"],
//   ['Агранова', "Маша"],
// ];

// // // возвращает массив, состоящий из двух первых пользователей
// let someUsers = users.filter(item => item[0] === 'Агранова');

// console.log(someUsers); //

// Преобразование массива
// map
// Метод arr.map является одним из наиболее полезных и часто используемых.
// Он вызывает функцию для каждого элемента массива
// и возвращает массив результатов выполнения этой функции.

// Синтаксис:
// let result = arr.map(function(item, index, array) {
//   // возвращается новое значение вместо элемента
// });
// Например, здесь мы преобразуем каждый элемент в его длину:
// let lengths = ["Bilbo", "Gandalf", "Nazgul"].map(item => item.length);

// let arr = ["Bilbo", "Gandalf", "Nazgul"];

// let arrMapping = arr.map(
// 	function(item) {
// 		if (item === "Nazgul") {
// 			return "Hobbit"
// 		}
// 		return item
// 	}
// )

// console.log(arrMapping)

// console.log(lengths); // 5,7,6

// split и join - разбивка и соединение строк в массивы

// let names = 'Вася, Петя, Маша';

// let arr = names.split(', ');

// for (let name of arr) {
//   console.log( `Сообщение получат: ${name}.` ); // Сообщение получат: Вася (и другие имена)
// }

// У метода split есть необязательный второй числовой аргумент
// – ограничение на количество элементов в массиве.
// Если их больше, чем указано, то остаток массива будет отброшен.
// На практике это редко используется:

// let arr = 'Вася, Петя, Маша, Саша'.split(', ', 2);
// console.log(arr); // Вася, Петя

// Разбивка по буквам
// Вызов split(s) с пустым аргументом s разбил бы строку на массив букв:
// let str = "тест";
// console.log( str.split('') ); // т,е,с,т

// Вызов arr.join(glue) делает в точности противоположное split.
// Он создаёт строку из элементов arr, вставляя glue между ними.

// Например:
// let arr = ['Вася', 'Петя', 'Маша'];
// let str = arr.join(' '); // объединить массив в строку через ;

// console.log( str ); // Вася;Петя;Маша

// Итого
// Шпаргалка по методам массива:

// Для добавления/удаления элементов:

// push (...items) – добавляет элементы в конец,
// pop() – извлекает элемент с конца,
// shift() – извлекает элемент с начала,
// unshift(...items) – добавляет элементы в начало.
// splice(pos, deleteCount, ...items) – начиная с индекса pos, удаляет deleteCount элементов и вставляет items.
// slice(start, end) – создаёт новый массив, копируя в него элементы с позиции start до end (не включая end).
// concat(...items) – возвращает новый массив: копирует все члены текущего массива и добавляет к нему items. Если какой-то из items является массивом, тогда берутся его элементы.

// Для поиска среди элементов:
// indexOf/lastIndexOf(item, pos) – ищет item, начиная с позиции pos, и возвращает его индекс или -1, если ничего не найдено.
// includes(value) – возвращает true, если в массиве имеется элемент value, в противном случае false.
// find/filter(func) – фильтрует элементы через функцию и отдаёт первое/все значения, при прохождении которых через функцию возвращается true.
// findIndex похож на find, но возвращает индекс вместо значения.

// Для перебора элементов:
// forEach(func) – вызывает func для каждого элемента. Ничего не возвращает.

// Для преобразования массива:
// map(func) – создаёт новый массив из результатов вызова func для каждого элемента.
// sort(func) – сортирует массив «на месте», а потом возвращает его.
// reverse() – «на месте» меняет порядок следования элементов на противоположный и возвращает изменённый массив.
// split/join – преобразует строку в массив и обратно.
// reduce(func, initial) – вычисляет одно значение на основе всего массива, вызывая func для каждого элемента и передавая промежуточный результат между вызовами.

// Дополнительно:
// Array.isArray(arr) проверяет, является ли arr массивом.

// Последнее - синтаксический сахар
// деструктуризация массива

// синтаксис для массива:
// let [item1 = default, item2, ...rest] = array

// Первый элемент отправляется в item1;
// второй отправляется в item2,
// все остальные элементы попадают в массив rest.

// Можно извлекать данные из вложенных объектов и массивов,
// для этого левая сторона должна иметь ту же структуру, что и правая.

// Пример деструктуризации массива:

// // у нас есть массив с именем и фамилией

// let arr = ["Ilya", "Kantor"]
// let [firstName, surname] = arr;

// console.log(firstName)
// console.log(surname)
// // деструктурирующее присваивание
// записывает firstName=arr[0], surname=arr[1]

// console.log(firstName); // Ilya
// console.log(surname);  // Kantor

// оператор rest - Остаточные параметры «…»
// Если мы хотим не просто получить первые значения,
// но и собрать все остальные, то мы можем добавить ещё один параметр,
// который получает остальные значения, используя оператор
// «остаточные параметры» – троеточие ("..."):

// let [name1, name2, ...rest] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];

// console.log(name1); // Julius
// console.log(name2); // Caesar
// console.log(rest); // ["Consul", "of the Roman Republic"]

// // Обратите внимание, что `rest` является массивом.
// console.log(rest[0]); // Consul
// console.log(rest[1]); // of the Roman Republic
// console.log(rest.length); // 2

// Фильтрация по диапазону

// Напишите функцию filterRange(arr, a, b), которая принимает массив arr,
// ищет элементы со значениями больше или равными a и меньше или равными b и возвращает результат в виде массива.

// Функция должна возвращать новый массив и не изменять исходный.

// Например:
// let arr = [5, 3, 8, 1];
// let filtered = filterRange(arr, 1, 4);

// console.log( filtered ); // 3,1 (совпадающие значения)
// console.log( arr ); // 5,3,8,1 (без изменений)

// Напишите функцию filterRangeInPlace(arr, a, b),
// которая принимает массив arr и удаляет из него все значения кроме тех,
// которые находятся между a и b. То есть, проверка имеет вид a ≤ arr[i] ≤ b.

// Функция должна изменять принимаемый массив и ничего не возвращать.

// Например:
// let arr = [5, 3, 8, 1];
// filterRangeInPlace(arr, 1, 4); // удалены числа вне диапазона 1..4
// alert( arr ); // [3, 1]// Перебор: forEach
// Метод arr.forEach позволяет запускать функцию для каждого элемента массива

// Его синтаксис:
// arr.forEach(
// 		function(item, index, array) {
// 	  // ... делать что-то с item
// 		}
// );

// Например, этот код выведет на экран каждый элемент массива:
// Вызов console.log для каждого элемента
// ["Bilbo", "Gandalf", "Nazgul"].forEach(
// 	(item, index, array) => {
// 	  console.log(`${item} имеет позицию ${index} в ${array}`);
// 	  console.log(array);
// 	}
// );

// includes - Поиск в массиве
// arr.includes(item, from) – ищет item, начиная с индекса from,
// и возвращает true, если поиск успешен.

// let arr = [1, 0, false];
// console.log( arr.includes(1) ); // true

// const arr = [NaN];
// console.log( arr.includes(NaN) );// true (верно)

// углубленный поиск в массиве find
// Представьте, что у нас есть массив массивов.
// Как нам найти вложенный массив с определённым условием?

// Здесь пригодится метод arr.find.
// Его синтаксис таков:
// let result = arr.find(
// 		function(item, index, array) {
// 	  // если true - возвращается текущий элемент и перебор прерывается
// 	  // если все итерации оказались ложными, возвращается undefined
// 	}
// );

// Функция вызывается по очереди для каждого элемента массива:
// item – очередной элемент.
// index – его индекс.
// array – сам массив.
// Если функция возвращает true, поиск прерывается и возвращается item.
// Если ничего не найдено, возвращается undefined.

// Например, у нас есть массив c массивами пользователей,
// каждый из которых имеет первым элементом фамилию, вторым имя.
// Попробуем найти того, кто с фамилией Агранова

// let users = [
//   ['Иванов', "Вася"],
//   ['Петров', "Петя"],
//   ['Агранова', "Соня"],
// ];

// let user = users.find(item => item[0] == 'Агранова');

// console.log(user); //

// отфильтровать массив - filter
// Синтаксис этого метода схож с find, но
// filter возвращает массив из всех подходящих элементов

// let results = arr.filter(function(item, index, array) {
//   // если true - элемент добавляется к результату, и перебор продолжается
//   // возвращается пустой массив в случае, если ничего не найдено
// });

// let users = [
//   ['Иванов', "Вася"],
//   ['Агранова', "Петя"],
//   ['Агранова', "Маша"],
// ];

// // // возвращает массив, состоящий из двух первых пользователей
// let someUsers = users.filter(item => item[0] === 'Агранова');

// console.log(someUsers); //

// Преобразование массива
// map
// Метод arr.map является одним из наиболее полезных и часто используемых.
// Он вызывает функцию для каждого элемента массива
// и возвращает массив результатов выполнения этой функции.

// Синтаксис:
// let result = arr.map(function(item, index, array) {
//   // возвращается новое значение вместо элемента
// });
// Например, здесь мы преобразуем каждый элемент в его длину:
// let lengths = ["Bilbo", "Gandalf", "Nazgul"].map(item => item.length);

// let arr = ["Bilbo", "Gandalf", "Nazgul"];


// let arrMapping = arr.map(
// 	function(item) {
// 		if (item === "Nazgul") {
// 			return "Hobbit"
// 		}
// 		return item
// 	}
// )

// console.log(arrMapping)

// console.log(lengths); // 5,7,6

// split и join - разбивка и соединение строк в массивы

// let names = 'Вася, Петя, Маша';

// let arr = names.split(', ');

// for (let name of arr) {
//   console.log( `Сообщение получат: ${name}.` ); // Сообщение получат: Вася (и другие имена)
// }


// У метода split есть необязательный второй числовой аргумент
// – ограничение на количество элементов в массиве.
// Если их больше, чем указано, то остаток массива будет отброшен.
// На практике это редко используется:

// let arr = 'Вася, Петя, Маша, Саша'.split(', ', 2);
// console.log(arr); // Вася, Петя

// Разбивка по буквам
// Вызов split(s) с пустым аргументом s разбил бы строку на массив букв:
// let str = "тест";
// console.log( str.split('') ); // т,е,с,т

// Вызов arr.join(glue) делает в точности противоположное split.
// Он создаёт строку из элементов arr, вставляя glue между ними.

// Например:
// let arr = ['Вася', 'Петя', 'Маша'];
// let str = arr.join(' '); // объединить массив в строку через ;

// console.log( str ); // Вася;Петя;Маша


// Итого
// Шпаргалка по методам массива:

// Для добавления/удаления элементов:

// push (...items) – добавляет элементы в конец,
// pop() – извлекает элемент с конца,
// shift() – извлекает элемент с начала,
// unshift(...items) – добавляет элементы в начало.
// splice(pos, deleteCount, ...items) – начиная с индекса pos, удаляет deleteCount элементов и вставляет items.
// slice(start, end) – создаёт новый массив, копируя в него элементы с позиции start до end (не включая end).
// concat(...items) – возвращает новый массив: копирует все члены текущего массива и добавляет к нему items. Если какой-то из items является массивом, тогда берутся его элементы.

// Для поиска среди элементов:
// indexOf/lastIndexOf(item, pos) – ищет item, начиная с позиции pos, и возвращает его индекс или -1, если ничего не найдено.
// includes(value) – возвращает true, если в массиве имеется элемент value, в противном случае false.
// find/filter(func) – фильтрует элементы через функцию и отдаёт первое/все значения, при прохождении которых через функцию возвращается true.
// findIndex похож на find, но возвращает индекс вместо значения.

// Для перебора элементов:
// forEach(func) – вызывает func для каждого элемента. Ничего не возвращает.

// Для преобразования массива:
// map(func) – создаёт новый массив из результатов вызова func для каждого элемента.
// sort(func) – сортирует массив «на месте», а потом возвращает его.
// reverse() – «на месте» меняет порядок следования элементов на противоположный и возвращает изменённый массив.
// split/join – преобразует строку в массив и обратно.
// reduce(func, initial) – вычисляет одно значение на основе всего массива, вызывая func для каждого элемента и передавая промежуточный результат между вызовами.

// Дополнительно:
// Array.isArray(arr) проверяет, является ли arr массивом.

// Последнее - синтаксический сахар
// деструктуризация массива

// синтаксис для массива:
// let [item1 = default, item2, ...rest] = array

// Первый элемент отправляется в item1;
// второй отправляется в item2,
// все остальные элементы попадают в массив rest.

// Можно извлекать данные из вложенных объектов и массивов,
// для этого левая сторона должна иметь ту же структуру, что и правая.

// Пример деструктуризации массива:

// // у нас есть массив с именем и фамилией

// let arr = ["Ilya", "Kantor"]
// let [firstName, surname] = arr;

// console.log(firstName)
// console.log(surname)
// // деструктурирующее присваивание
// записывает firstName=arr[0], surname=arr[1]

// console.log(firstName); // Ilya
// console.log(surname);  // Kantor


// оператор rest - Остаточные параметры «…»
// Если мы хотим не просто получить первые значения,
// но и собрать все остальные, то мы можем добавить ещё один параметр,
// который получает остальные значения, используя оператор
// «остаточные параметры» – троеточие ("..."):

// let [name1, name2, ...rest] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];

// console.log(name1); // Julius
// console.log(name2); // Caesar
// console.log(rest); // ["Consul", "of the Roman Republic"]

// // Обратите внимание, что `rest` является массивом.
// console.log(rest[0]); // Consul
// console.log(rest[1]); // of the Roman Republic
// console.log(rest.length); // 2

// Фильтрация по диапазону

// Напишите функцию filterRange(arr, a, b), которая принимает массив arr,
// ищет элементы со значениями больше или равными a и меньше или равными b и возвращает результат в виде массива.

// Функция должна возвращать новый массив и не изменять исходный.

// Например:
// let arr = [5, 3, 8, 1];
// let filtered = filterRange(arr, 1, 4);

// console.log( filtered ); // 3,1 (совпадающие значения)
// console.log( arr ); // 5,3,8,1 (без изменений)


// Напишите функцию filterRangeInPlace(arr, a, b),
// которая принимает массив arr и удаляет из него все значения кроме тех,
// которые находятся между a и b. То есть, проверка имеет вид a ≤ arr[i] ≤ b.

// Функция должна изменять принимаемый массив и ничего не возвращать.

// Например:
// let arr = [5, 3, 8, 1];
// filterRangeInPlace(arr, 1, 4); // удалены числа вне диапазона 1..4
// alert( arr ); // [3, 1]
